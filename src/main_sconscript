import os

varfile = ARGUMENTS.get('VARS', 'vars.py')
vars = Variables(varfile)
vars.Add('CPUS', 'Set number of CPUs', '1')
vars.Add('READS', 'Read file(s) to map in FASTQ format. If paired-end a comma separated list.', '') 
vars.Add('MAPPER', 'The aligner to map reads to the genome', 'segemehl') 
vars.Add('SCRIPT_PATH', 'Path to SConscript files', '#src')
vars.Add('PREPROCESSOR', 'The preprocessing method', 'trimmomatic')
vars.Add('ADAPTER_FILE', 'FASTA file full path of the adapter sequence', '')
vars.Add('ANNOTATION', 'Gene annotation (Ensembl GFF)', '')

env = Environment(variables = vars,
                  ENV = os.environ,
                  SEGEMEHL_INDEX = os.environ['SEGEMEHL_INDEX'],
                  GENOME_FASTA = os.environ['GENOME_FASTA'],
                  PREPROCESSOR = '${PREPROCESSOR}',
                  ADAPTER_FILE = '${ADAPTER_FILE}',
                  MAPPER = '${MAPPER}',
                  SAMPLE = os.path.basename(Dir('.').abspath),
                  ANNOTATION = '${ANNOTATION}',
                  SCRIPT_PATH = '${SCRIPT_PATH}'
                  )
Help(vars.GenerateHelpText(env))

## SET (DISPATCHER) SCRIPT NAMES. THESE ARE THE MAIN PIPELINE STEPS, EACH OF THEM MIGHT FIRE
## DIFFERENT ACTIONS/SCONSCRIPTS
read_statistics_sconscript = 'read_statistics_sconscript'
preprocess_sconscript   = 'preprocess_sconscript'
mapping_sconscript      = 'mapping_sconscript'
expression_sconscript   = 'expression_sconscript'

Import('*')

read_dir = 'data'
read_file_list = [f for f in os.listdir(read_dir) if os.path.isfile(os.path.join(read_dir, f))]
read_files = ','.join(sorted(['#'+os.path.join(Dir('.').path, read_dir, f) for f in read_file_list]))
env['READS'] = read_files

Export('env')

build_dir = 'build'

raw_read_stats = []
for f in read_files.split(','):
    env.Replace(FILE_TO_PROCESS = '#'+File(f).path)
    raw_read_stats.append(SConscript(os.path.join(build_dir, 
                                                  'read_statistics_sconscript'),
                                     src_dir=env['SCRIPT_PATH'], 
                                     variant_dir=build_dir, duplicate=0))

## EXECUTE SCRIPTS
preprocess  = env.SConscript(os.path.join(build_dir, preprocess_sconscript), variant_dir=build_dir, 
                             src_dir=env['SCRIPT_PATH'], duplicate=0)
vars.Add('CLEAN_READS', 'Clean-read files', '')
vars.Update(env)
## set the clean read file paths, relative to the calling SConstruct (not the calling SConscript).
## Implementation note: here you should know what the preprocess SConscript returns to handle it 
## properly. For instance: Trimmomatic with paired-end reads gives four output read files and 
## you probably want to use the 0 and 2 indexed files of the returned list (i.e. the processed 
## reads with mate read). Instead, if no preprocessing was performed, the clean reads are the raw
## reads and the list is only two elements (for paired-end reads)
clean_reads = [preprocess[0]]
## paired end case
if len(read_file_list)>1:
    ## case: Trimmomatic paired-end
    if env['PREPROCESSOR']=='trimmomatic':
        clean_reads.append(preprocess[2])
    ## case: no preprocessing was performed
    else:
        clean_reads.append(preprocess[1])

env['CLEAN_READS'] = ','.join(sorted(['#'+c.path for c in clean_reads]))

mappings    = env.SConscript(os.path.join(build_dir, mapping_sconscript), variant_dir=build_dir,
                             src_dir=env['SCRIPT_PATH'], duplicate=0)

env.Replace(MAPPING_FILE = '#'+mappings[0].path)

expression  = env.SConscript(os.path.join(build_dir, expression_sconscript), variant_dir=build_dir,
                             src_dir=env['SCRIPT_PATH'], duplicate=0)

#print  [e.path for node in expression for e in node]
