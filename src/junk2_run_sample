import os, itertools

varfile = ARGUMENTS.get('VARS', 'vars.py')
vars = Variables(varfile)
vars.Add('CPUS', 'Set number of CPUs', '1')
vars.Add('MAPPER', 'The aligner to map reads to the genome', 'segemehl') 
vars.Add('PREPROCESSOR', 'The preprocessing method', 'trimmomatic')
vars.Add('ADAPTER_FILE', 'FASTA file full path of the adapter sequence', '')
vars.Add('ANNOTATION', 'Gene annotation (Ensembl GFF)', '')
vars.Add('GENOME_FASTA', '', '')
vars.Add('GENOME_INDEX', '', '')

env = Environment(variables = vars,
                  ENV = os.environ,
                  CPUS = '${CPUS}',
                  GENOME_INDEX = '${GENOME_INDEX}',
                  GENOME_FASTA = '${GENOME_FASTA}',
                  PREPROCESSOR = '${PREPROCESSOR}',
                  ADAPTER_FILE = '${ADAPTER_FILE}',
                  MAPPER = '${MAPPER}',
                  ANNOTATION = '${ANNOTATION}'
                  )
Help(vars.GenerateHelpText(env))

## SET (DISPATCHER) SCRIPT NAMES. THESE ARE THE MAIN PIPELINE STEPS, EACH OF THEM MIGHT FIRE
## DIFFERENT ACTIONS/SCONSCRIPTS
junk2_read_statistics   = 'junk2_read_statistics'
junk2_preprocess        = 'junk2_preprocess'
junk2_mapping           = 'junk2_mapping'
junk2_expression        = 'junk2_expression'

Import('*')

try:
    rr = raw_reads
except NameError:
    try:
        raw_reads = []
        for key, value in ARGLIST:
            if key == 'READS':
                raw_reads.append(value)
    except NameError:
        sys.exit('Error: raw reads not defined!')

SRC_DIR = os.path.join(env['ENV']['JUNK2_HOME'], 'src')

results = []

## COMPUTE STATISTICS ON RAW READS
read_statistics_dir = 'read_statistics'
raw_read_make_dir = env.Command(Dir(read_statistics_dir), [], Mkdir('$TARGET'))
raw_read_stats = []
for readset in raw_reads:
    stat = SConscript(os.path.join(read_statistics_dir, junk2_read_statistics), 
                      src_dir=SRC_DIR, variant_dir=read_statistics_dir, duplicate=0,
                      exports='env readset')
    raw_read_stats.append(stat)
results.append(raw_read_stats)

build_dir = 'processings'

## EXECUTE SCRIPTS
preprocess  = env.SConscript(os.path.join(build_dir, junk2_preprocess), 
                             variant_dir = build_dir, src_dir = SRC_DIR, 
                             duplicate = 0, exports='env raw_reads')
results.append(preprocess)
### set the clean read file paths, relative to the calling SConstruct (not the calling SConscript).
### Implementation note: here you should know what the preprocess SConscript returns to handle it 
### properly. For instance: Trimmomatic with paired-end reads gives four output read files and 
### you probably want to use the 0 and 2 indexed files of the returned list (i.e. the processed 
### reads with mate read). Instead, if no preprocessing was performed, the clean reads are the raw
### reads and the list is only two elements (for paired-end reads)
clean_reads = [preprocess[0][0]]
## paired end case
if len(preprocess[0])>1:
    ## case: Trimmomatic paired-end
    if env['PREPROCESSOR']=='trimmomatic':
        clean_reads.append(preprocess[0][2])
    ## case: no preprocessing was performed
    else:
        clean_reads.append(preprocess[0][1])

env['SAMPLE'] = os.path.basename(Dir('.').path)
sample_name = os.path.basename(Dir('.').path)

mapper = env['MAPPER']
genome_index = env['GENOME_INDEX']
genome_fasta = env['GENOME_FASTA']
sample_id = env['SAMPLE']
mapper_extra_params = ''
mapper_cpus = env['CPUS']
mappings    = env.SConscript(os.path.join(build_dir, junk2_mapping), 
                             variant_dir = build_dir, src_dir = SRC_DIR, 
                             duplicate = 0, exports = 'env clean_reads mapper genome_index genome_fasta sample_id mapper_extra_params mapper_cpus')
results.append(mappings)

mapping_file = mappings[0][0]
expression  = env.SConscript(os.path.join(build_dir, junk2_expression), 
                             variant_dir = build_dir, src_dir = SRC_DIR, 
                             duplicate = 0, exports = 'env mapping_file sample_name')
results.append(expression)
#print  [e.path for node in expression for e in node]

Return('results')
