import os

varfile = ARGUMENTS.get('VARS', 'vars.py')
vars = Variables(varfile)
vars.Add('CPUS', 'Set number of CPUs', '1')
vars.Add('MAPPER', 'The aligner to map reads to the genome', 'segemehl') 
vars.Add('PREPROCESSOR', 'The preprocessing method', 'trimmomatic')
vars.Add('ADAPTER_FILE', 'FASTA file full path of the adapter sequence', '')
vars.Add('ANNOTATION', 'Gene annotation (Ensembl GFF)', '')
vars.Add('GENOME_FASTA', '', '')
vars.Add('GENOME_INDEX', '', '')

env = Environment(variables = vars,
                  ENV = os.environ,
                  GENOME_INDEX = '${GENOME_INDEX}',
                  GENOME_FASTA = '${GENOME_FASTA}',
                  PREPROCESSOR = '${PREPROCESSOR}',
                  ADAPTER_FILE = '${ADAPTER_FILE}',
                  MAPPER = '${MAPPER}',
                  ANNOTATION = '${ANNOTATION}'
                  )
Help(vars.GenerateHelpText(env))

## SET (DISPATCHER) SCRIPT NAMES. THESE ARE THE MAIN PIPELINE STEPS, EACH OF THEM MIGHT FIRE
## DIFFERENT ACTIONS/SCONSCRIPTS
junk2_read_statistics   = 'junk2_read_statistics'
junk2_preprocess        = 'junk2_preprocess'
junk2_mapping           = 'junk2_mapping'
junk2_expression        = 'junk2_expression'

Import('*')

try:
    rr = raw_reads
except NameError:
    try:
        raw_reads = []
        for key, value in ARGLIST:
            if key == 'READS':
                raw_reads.append(value)
    except NameError:
        sys.exit('Error: raw reads not defined!')

SRC_DIR = os.path.join(env['ENV']['JUNK2_HOME'], 'src')

results = []

## COMPUTE STATISTICS ON RAW READS
read_statistics_dir = 'read_statistics'
raw_read_make_dir = env.Command(Dir(read_statistics_dir), [], Mkdir('$TARGET'))
raw_read_stats = []
for readset in raw_reads:
    stat = SConscript(os.path.join(read_statistics_dir, junk2_read_statistics), 
                      src_dir=SRC_DIR, variant_dir=read_statistics_dir, duplicate=0,
                      exports='env readset')
    raw_read_stats.append(stat)


#read_dir = 'data'
#read_file_list = [f for f in os.listdir(read_dir) if os.path.isfile(os.path.join(read_dir, f))]
#read_files = ','.join(sorted(['#'+os.path.join(Dir('.').path, read_dir, f) for f in read_file_list]))
#env['READS'] = read_files
#
#Export('env')

build_dir = 'processings'

## EXECUTE SCRIPTS
preprocess  = env.SConscript(os.path.join(build_dir, junk2_preprocess), 
                             variant_dir=build_dir, src_dir=SRC_DIR, duplicate=0,
                             exports='env raw_reads')

#vars.Add('CLEAN_READS', 'Clean-read files', '')
#vars.Update(env)
### set the clean read file paths, relative to the calling SConstruct (not the calling SConscript).
### Implementation note: here you should know what the preprocess SConscript returns to handle it 
### properly. For instance: Trimmomatic with paired-end reads gives four output read files and 
### you probably want to use the 0 and 2 indexed files of the returned list (i.e. the processed 
### reads with mate read). Instead, if no preprocessing was performed, the clean reads are the raw
### reads and the list is only two elements (for paired-end reads)
#clean_reads = [preprocess[0]]
### paired end case
#if len(read_file_list)>1:
#    ## case: Trimmomatic paired-end
#    if env['PREPROCESSOR']=='trimmomatic':
#        clean_reads.append(preprocess[2])
#    ## case: no preprocessing was performed
#    else:
#        clean_reads.append(preprocess[1])
#
#env['CLEAN_READS'] = ','.join(sorted(['#'+c.path for c in clean_reads]))
#
#mappings    = env.SConscript(os.path.join(build_dir, mapping_sconscript), variant_dir=build_dir,
#                             src_dir=env['SCRIPT_PATH'], duplicate=0)
#
#env.Replace(MAPPING_FILE = '#'+mappings[0].path)
#
#expression  = env.SConscript(os.path.join(build_dir, expression_sconscript), variant_dir=build_dir,
#                             src_dir=env['SCRIPT_PATH'], duplicate=0)
#
##print  [e.path for node in expression for e in node]


Return('results')
